学习笔记
课程结束了，说是话这段时间自己并非是很用心的在学习，总是因为太忙会找借口不去学习，很遗憾课程结束了，但是之后不会落下这段时间的收获，习题应该也养成习惯了，会继续保持下去。


*最大误区：人肉进行递归
*找最近最简方法，拆解成可重复解决的子问题
*数学归纳法思维

1.数组（array）：

​	需要一块连续的内存空间

​	读取复杂度为0(1)；插入/删除复杂度为O(n)

2.链表（Linked List）：

​	存储空间不需要连续

​	读取复杂度0(n)；插入/删除复杂度为O(1)

3.跳表（Skip List）：

​	插入/删除/搜索：O(log n)

​	优势：原理简单，容易实现，方便操作，效率更高

​	*只能用于**元素**有序的情况*

4.栈（Stack）：

​	先入后出（FILO）

​	添加、删除皆为 O(1)

5.队列（Queue）：

​	先入先出（FIFO）

​	添加、删除皆为 O(1)

6.哈希表（Hash table）
​		也称散列表，是根据关键码值（Keyvalue）而直接进行访问的数据结构。它通过把关键码值映射到表中一个位置来访问记录，以加快查找的 速度。

7.二叉树遍历 Pre-order/In-order/Post-order

​		1.前序（Pre-order）：根-左-右 

​		2.中序（In-order）：左-根-右 

​		3.后序（Post-order）：左-右-根

8.二叉搜索树 Binary Search Tree

​		二叉搜索树，也称二叉排序树、有序二叉树（Ordered Binary Tree）、排序二叉树（Sorted Binary Tree），是指一棵空树或者具有下列性质的二叉树： 

​		1.左子树上所有结点的值均小于它的根结点的值； 

​        2.右子树上所有结点的值均大于它的根结点的值； 

​        3.以此类推：左、右子树也分别为二叉查找树。

9.递归

 递归，本质就是循环。通过函数体进行的循环。

模板：

​	1.terminator

​	2.process current logic

​	3.drill down

​	4.restore current status



10.回溯
​	回溯采取的是试错思想，通过递归不断试错，反复重复后会有两种结果：一是找到一个可能存在正确答案；二是尝遍所有解法最终得出无解。

在最坏的情况下，回溯法会导致一次复杂度为指数时间的计算。

11.深度优先搜索（depth first search）和广度优先搜索（breadth first search）

1.每个节点都要访问一次

2.每个节点仅仅访问一次

3.对于节点的访问顺序不限

深度优先搜索（depth first search）：先探索到**最深一层**，再依次返回查询上一节点的子节点，探索到最深层再返回。

广度优先搜索（breadth first search）：**一层一层**依次探寻该节点的子节点，一层完毕再探索一层。

12.贪心算法（Greedy）

每一步都会选择最优解。它对于每一个子问题的解决方案都做出选择，不能回退（此点同动态规划做对比：动态规划有回退功能）。

贪心法可以解决一些最优化问题，如：求图中的最小生成树、求哈夫曼编码等。然而对于工程和生活中的问题，贪心法一般不能得到我们所要求的答案。 

一旦一个问题可以通过贪心法来解决，那么贪心法一般是解决这个问题的最 好办法。由于贪心法的高效性以及其所求得的答案比较接近最优结果，贪心法也可以用作辅助算法或者直接解决一些要求结果不特别精确的问题。

*适用贪心算法的场景：

问题能够分解成子问题解决，子问题的最优解能递推到最终问题的最优解。这种子问题最优解称为**最优子结构**。

13.二分查找

二分查找的前提：

1.目标函数单调性（单调递增或递减）

2.存在上下边界

3.能够通过索引访问

14.动态规划：

​	1.动态规划 和 递归 或者 分治 没有根本上的区别（关键看有无最优的子结构）。

​	2.共性：找到重复子问题。

​	3.差异性：最优子结构、中途可以淘汰次优解。

15.字典树：

​		字典树，即 Trie 树，又称单词 查找树或键树，是一种树形结构。

​		优点：

​				最大限度地减少无谓的字符串比较，查询效率 比哈希表高。

​		基本性质：

​				1.结点本身不存完整单词； 

​				2.从根结点到某一结点，路径上经过的字符连接起来，为该结点对应的 字符串； 

​				3.每个结点的所有子结点路径代表的字符都不相同。

​		核心思想：

​				Trie 树的核心思想是空间换时间。利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目		的。

16.并查集：

​		基本操作：

​				• makeSet(s)：建立一个新的并查集，其中包含 s 个单元素集合。 

​				• unionSet(x, y)：把元素 x 和元素 y 所在的集合合并，要求 x 和 y 所在 的集合不相交，如果相交则不合		并。 			

​				• find(x)：找到元素 x 所在的集合的代表，该操作也可以用于判断两个元 素是否位于同一个集合，只要		将它们各自的代表比较一下就可以了。

17.回溯法：
	回溯法采用试错的思想，它尝试分步的去解决一个问题。在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。 

​		回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种情况：

​			1.找到一个可能存在的正确的答案

​			2.在尝试了所有可能的分步方法后宣告该问题没有答案

​		在最坏的情况下，回溯法会导致一次复杂度为指数时间的计算。回溯法会导致一次复杂度为指数时间的计算

18.AVL树：

		1. 发明者 G. M. Adelson-Velsky和 Evgenii Landis 
  		2. Balance Factor（平衡因子）： 是它的左子树的高度减去它的右子树的高度（有时相反）。 balance factor = {-1, 0, 1} 
  		3. 通过旋转操作来进行平衡（四种）

19.红黑树：

​		红黑树是一种近似平衡的二叉搜索树（Binary Search Tree），它能够确保任何一 个结点的左右子树的高度差小于两倍。具体来说，红黑树是满足如下条件的二叉搜索树：

 • 每个结点要么是红色，要么是黑色 • 根结点是黑色 

• 每个叶结点（NIL结点，空结点）是黑色的。

• 不能有相邻接的两个红色结点

• 从任一结点到其每个叶子的所有路径都包含相同数目的黑色结点。

20.Bloom Filter vs Hash Table：

一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索 一个元素是否在一个集合中。 优点是空间效率和查询时间都远远超过一般的算法， 缺点是有一定的误识别率和删除困难。

优点是空间效率和查询时间都远远超过一般的算法， 缺点是有一定的误识别率和删除困难。

21.LRU Cache：

• 两个要素： 大小 、替换策略 

• Hash Table + Double LinkedList 

• O(1) 查询 O(1) 修改、更新

22.排序算法：

1. 比较类排序： 通过比较来决定元素间的相对次序，由于其时间复杂度不能突破 O(nlogn)，因此也称为非线性时间比较类排序。
2. 比较类排序： 不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时 间下界，以线性时间运行，因此也称为线性时间非比较类排序。

23.初级排序 - O(n^2)：

1. 选择排序（Selection Sort） 每次找最小值，然后放到待排序数组的起始位置。 
2. 插入排序（Insertion Sort） 从前到后逐步构建有序序列；对于未排序数据，在已排序序列中从后 向前扫描，找到相应位置并插入。
3. 冒泡排序（Bubble Sort） 嵌套循环，每次查看相邻的元素如果逆序，则交换。

24.高级排序 - O(N*LogN)：

 • 快速排序（Quick Sort） 数组取标杆 pivot，将小元素放 pivot左边，大元素放右侧，然后依 次对右边和右边的子数组继续快排；以达到整个序列有序。

先调配出左右子数组，然后对于左右子数组进行排序

• 归并排序（Merge Sort）— 分治 1. 把长度为n的输入序列分成两个长度为n/2的子序列； 2. 对这两个子序列分别采用归并排序； 3. 将两个排序好的子序列合并成一个最终的排序序列。

先排序左右子数组，然后合并两个有序子数组

• 堆排序（Heap Sort） — 堆插入 O(logN)，取最大/小值 O(1) 1. 数组元素依次建立小顶堆 2. 依次取堆顶元素，并删除

25.特殊排序 - O(n)：

• 计数排序（Counting Sort） 计数排序要求输入的数据必须是有确定范围的整数。将输入的数据值转化为键存 储在额外开辟的数组空间中；然后依次把计数大于 1 的填充回原数组 

• 桶排序（Bucket Sort） 桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到 有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方 式继续使用桶排序进行排）。

 • 基数排序（Radix Sort） 基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类 推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按 高优先级排序。
 



